## API Report File for "@microsoft/fast-element"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export const all: (key: any, searchAncestors?: boolean) => ReturnType<typeof DI.inject>;

// @public
export type AsyncRegistrationLocator = (key: Key) => Promise<Registration | null>;

// @public
export interface Container extends ServiceLocator {
    createChild(config?: Partial<Omit<ContainerConfiguration, "parentLocator">>): Container;
    getFactory<T extends Constructable>(key: T): Factory<T>;
    getResolver<K extends Key, T = K>(key: K | Key, autoRegister?: boolean): Resolver<T> | null;
    register(...params: any[]): Container;
    // Warning: (ae-forgotten-export) The symbol "Constructable" needs to be exported by the entry point di.d.ts
    registerFactory<T extends Constructable>(key: T, factory: Factory<T>): void;
    registerResolver<K extends Key, T = K>(key: K, resolver: Resolver<T>): Resolver<T>;
    registerTransformer<K extends Key, T = K>(key: K, transformer: Transformer_2<T>): boolean;
}

// Warning: (ae-forgotten-export) The symbol "ContextDecorator" needs to be exported by the entry point di.d.ts
//
// @public
export const Container: ContextDecorator<Container>;

// @public
export interface ContainerConfiguration {
    asyncRegistrationLocator: AsyncRegistrationLocator;
    defaultResolver(key: Key, handler: Container): Resolver;
    parentLocator: ParentLocator;
    responsibleForOwnerRequests: boolean;
}

// @public
export const ContainerConfiguration: Readonly<{
    default: Readonly<ContainerConfiguration>;
}>;

// Warning: (ae-internal-missing-underscore) The name "ContainerImpl" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class ContainerImpl implements DOMContainer {
    constructor(owner: any, config: ContainerConfiguration);
    // (undocumented)
    protected config: ContainerConfiguration;
    // (undocumented)
    createChild(config?: Partial<Omit<ContainerConfiguration, "parentLocator">>): Container;
    // (undocumented)
    get depth(): number;
    // (undocumented)
    get<K extends Key>(key: K): Resolved<K>;
    // (undocumented)
    getAll<K extends Key>(key: K, searchAncestors?: boolean): readonly Resolved<K>[];
    // (undocumented)
    getAsync<K extends Key>(key: K): Promise<Resolved<K>>;
    // (undocumented)
    getFactory<K extends Constructable>(Type: K): Factory<K>;
    // (undocumented)
    getResolver<K extends Key, T = K>(key: K | Key, autoRegister?: boolean): Resolver<T> | null;
    // (undocumented)
    handleContextRequests(enable: boolean): void;
    // (undocumented)
    has<K extends Key>(key: K, searchAncestors?: boolean): boolean;
    // (undocumented)
    protected owner: any;
    // (undocumented)
    get parent(): ContainerImpl | null;
    // (undocumented)
    register(...params: any[]): Container;
    // (undocumented)
    registerFactory<K extends Constructable>(key: K, factory: Factory<K>): void;
    // (undocumented)
    registerResolver<K extends Key, T = K>(key: K, resolver: Resolver<T>): Resolver<T>;
    // (undocumented)
    registerTransformer<K extends Key, T = K>(key: K, transformer: Transformer_2<T>): boolean;
    // (undocumented)
    get responsibleForOwnerRequests(): boolean;
}

// @public
export const DefaultResolver: Readonly<{
    none(key: Key): Resolver;
    singleton(key: Key): Resolver;
    transient(key: Key): Resolver;
}>;

// @public
export const DI: Readonly<{
    installAsContextRequestStrategy(fallback?: () => DOMContainer): void;
    createContainer(config?: Partial<ContainerConfiguration>): Container;
    findResponsibleContainer(target: EventTarget, fallback?: () => DOMContainer): DOMContainer;
    findParentContainer(target: EventTarget, fallback?: () => DOMContainer): DOMContainer;
    getOrCreateDOMContainer(target?: EventTarget, config?: Partial<Omit<ContainerConfiguration, "parentLocator">>): DOMContainer;
    getDependencies(Type: Constructable | Injectable): Key[];
    defineProperty(target: {}, propertyName: string, key: Key, respectConnection?: boolean): void;
    createContext: typeof createContext;
    inject(...dependencies: Key[]): (target: any, key?: string | number, descriptor?: PropertyDescriptor | number) => void;
    transient<T extends Constructable<{}>>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T>;
    singleton<T_1 extends Constructable<{}>>(target: T_1 & Partial<RegisterSelf<T_1>>, options?: SingletonOptions): T_1 & RegisterSelf<T_1>;
}>;

// @public
export interface DOMContainer extends Container {
    // @beta
    handleContextRequests(enable: boolean): void;
}

// @public
export const DOMContainer: ContextDecorator<DOMContainer>;

// @public
export interface Factory<T extends Constructable = any> {
    construct(container: Container, dynamicDependencies?: Key[]): Resolved<T>;
    constructAsync(container: Container, dynamicDependencies?: Key[]): Promise<Resolved<T>>;
    registerTransformer(transformer: Transformer_2<T>): void;
    readonly Type: T;
}

// Warning: (ae-internal-missing-underscore) The name "FactoryImpl" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class FactoryImpl<T extends Constructable = any> implements Factory<T> {
    constructor(Type: T, dependencies: Key[]);
    // (undocumented)
    construct(container: Container, dynamicDependencies?: Key[]): Resolved<T>;
    // (undocumented)
    constructAsync(container: Container, dynamicDependencies?: Key[]): Promise<Resolved<T>>;
    // (undocumented)
    registerTransformer(transformer: (instance: any) => any): void;
    // (undocumented)
    Type: T;
}

// @public
export function ignore(target: Injectable, property?: string | number, descriptor?: PropertyDescriptor | number): void;

// @public
export const inject: (...dependencies: Key[]) => (target: any, key?: string | number, descriptor?: PropertyDescriptor | number) => void;

// @public
export type Injectable<T = {}> = Constructable<T> & {
    inject?: Key[];
};

// @public
export interface InterfaceConfiguration {
    friendlyName?: string;
    respectConnection?: boolean;
}

// @public
export type Key = PropertyKey | object | ContextDecorator | Constructable | Resolver;

// @public
export const lazy: (key: any) => any;

// @public
export const newInstanceForScope: (key: any) => any;

// @public
export const newInstanceOf: (key: any) => any;

// @public
export const optional: (key: any) => any;

// @public
export type ParentLocator = (owner: any) => Container | null;

// @public
export type RegisterSelf<T extends Constructable> = {
    register(container: Container): Resolver<InstanceType<T>>;
    registerInRequestor: boolean;
};

// @public
export interface Registration<K = any> {
    register(container: Container): Resolver<K>;
}

// @public
export const Registration: Readonly<{
    instance<T>(key: Key, value: T): Registration<T>;
    singleton<T_1 extends Constructable<{}>>(key: Key, value: T_1): Registration<InstanceType<T_1>>;
    transient<T_2 extends Constructable<{}>>(key: Key, value: T_2): Registration<InstanceType<T_2>>;
    callback<T_3>(key: Key, callback: ResolveCallback<T_3>): Registration<Resolved<T_3>>;
    cachedCallback<T_4>(key: Key, callback: ResolveCallback<T_4>): Registration<Resolved<T_4>>;
    aliasTo<T_5>(originalKey: T_5, aliasKey: Key): Registration<Resolved<T_5>>;
}>;

// @public
export interface Registry {
    register(container: Container, ...params: unknown[]): void | Resolver;
}

// @public
export type ResolveCallback<T = any> = (handler: Container, requestor: Container, resolver: Resolver<T>) => T;

// Warning: (ae-forgotten-export) The symbol "ResolverLike" needs to be exported by the entry point di.d.ts
//
// @public
export type Resolved<K> = K extends ContextDecorator<infer T> ? T : K extends Constructable ? InstanceType<K> : K extends ResolverLike<any, infer T1> ? T1 extends Constructable ? InstanceType<T1> : T1 : K;

// @public
export interface Resolver<K = any> extends ResolverLike<Container, K> {
}

// @public
export class ResolverBuilder<K> {
    constructor(container: Container, key: Key);
    aliasTo(destinationKey: Key): Resolver<K>;
    cachedCallback(value: ResolveCallback<K>): Resolver<K>;
    callback(value: ResolveCallback<K>): Resolver<K>;
    instance(value: K): Resolver<K>;
    singleton(value: Constructable): Resolver<K>;
    transient(value: Constructable): Resolver<K>;
}

// Warning: (ae-internal-missing-underscore) The name "ResolverImpl" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class ResolverImpl implements Resolver, Registration {
    // (undocumented)
    get $isResolver(): true;
    constructor(key: Key, strategy: ResolverStrategy, state: any);
    // (undocumented)
    getFactory(container: Container): Factory | null;
    // (undocumented)
    key: Key;
    // (undocumented)
    register(container: Container): Resolver;
    // (undocumented)
    resolve(handler: Container, requestor: Container): any;
    // (undocumented)
    resolveAsync(handler: Container, requestor: Container): Promise<any>;
    // (undocumented)
    state: any;
    // (undocumented)
    strategy: ResolverStrategy;
}

// Warning: (ae-internal-missing-underscore) The name "ResolverStrategy" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const enum ResolverStrategy {
    // (undocumented)
    alias = 5,
    // (undocumented)
    array = 4,
    // (undocumented)
    callback = 3,
    // (undocumented)
    instance = 0,
    // (undocumented)
    singleton = 1,
    // (undocumented)
    transient = 2
}

// @public
export interface ServiceLocator {
    get<K extends Key>(key: K): Resolved<K>;
    get<K extends Key>(key: Key): Resolved<K>;
    get<K extends Key>(key: K | Key): Resolved<K>;
    getAll<K extends Key>(key: K, searchAncestors?: boolean): readonly Resolved<K>[];
    getAll<K extends Key>(key: Key, searchAncestors?: boolean): readonly Resolved<K>[];
    getAll<K extends Key>(key: K | Key, searchAncestors?: boolean): readonly Resolved<K>[];
    getAsync<K extends Key>(key: K): Promise<Resolved<K>>;
    getAsync<K extends Key>(key: Key): Promise<Resolved<K>>;
    getAsync<K extends Key>(key: K | Key): Promise<Resolved<K>>;
    has<K extends Key>(key: K | Key, searchAncestors: boolean): boolean;
}

// @public
export const ServiceLocator: ContextDecorator<ServiceLocator>;

// Warning: (ae-forgotten-export) The symbol "singletonDecorator" needs to be exported by the entry point di.d.ts
//
// @public
export function singleton<T extends Constructable>(): typeof singletonDecorator;

// @public (undocumented)
export function singleton<T extends Constructable>(options?: SingletonOptions): typeof singletonDecorator;

// @public
export function singleton<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T>;

// @public
type Transformer_2<K> = (instance: Resolved<K>) => Resolved<K>;
export { Transformer_2 as Transformer }

// Warning: (ae-forgotten-export) The symbol "transientDecorator" needs to be exported by the entry point di.d.ts
//
// @public
export function transient<T extends Constructable>(): typeof transientDecorator;

// @public
export function transient<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T>;

// Warning: (ae-internal-missing-underscore) The name "validateKey" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function validateKey(key: any): void;

// Warnings were encountered during analysis:
//
// dist/dts/di/di.d.ts:479:5 - (ae-forgotten-export) The symbol "createContext" needs to be exported by the entry point di.d.ts
// dist/dts/di/di.d.ts:540:5 - (ae-forgotten-export) The symbol "SingletonOptions" needs to be exported by the entry point di.d.ts

// (No @packageDocumentation comment for this package)

```
