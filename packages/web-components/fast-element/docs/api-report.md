## API Report File for "@microsoft/fast-element"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export interface Accessor {
    getValue(source: any): any;
    name: string;
    setValue(source: any, value: any): void;
}

// @public (undocumented)
export class AdoptedStyleSheetsStyles extends ElementStyles {
    constructor(styles: InjectableStyles[], styleSheetCache: Map<string, CSSStyleSheet>);
    // (undocumented)
    addStylesTo(target: StyleTarget): void;
    // (undocumented)
    readonly behaviors: ReadonlyArray<Behavior> | null;
    // (undocumented)
    removeStylesFrom(target: StyleTarget): void;
    // Warning: (ae-forgotten-export) The symbol "InjectableStyles" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    styles: InjectableStyles[];
    }

// @public (undocumented)
export class AttachedBehaviorDirective<T = any> extends Directive {
    constructor(name: string, behavior: AttachedBehaviorType<T>, options: T);
    // (undocumented)
    createBehavior(target: any): Behavior;
    // (undocumented)
    createPlaceholder(index: number): string;
    }

// @public (undocumented)
export type AttachedBehaviorType<T = any> = new (target: any, options: T) => Behavior;

// @public
export function attr(config?: DecoratorAttributeConfiguration): (target: {}, property: string) => void;

// @public
export function attr(target: {}, prop: string): void;

// @public (undocumented)
export type AttributeConfiguration = {
    property: string;
    attribute?: string;
    mode?: AttributeMode;
    converter?: ValueConverter;
};

// @public (undocumented)
export class AttributeDefinition implements Accessor {
    constructor(Owner: Function, name: string, attribute?: string, mode?: AttributeMode, converter?: ValueConverter | undefined);
    // (undocumented)
    readonly attribute: string;
    // (undocumented)
    static collect(Owner: Function, ...attributeLists: (ReadonlyArray<string | AttributeConfiguration> | undefined)[]): ReadonlyArray<AttributeDefinition>;
    // (undocumented)
    readonly converter?: ValueConverter | undefined;
    // (undocumented)
    getValue(source: HTMLElement): any;
    // (undocumented)
    readonly mode: AttributeMode;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    onAttributeChangedCallback(element: HTMLElement, value: any): void;
    // (undocumented)
    readonly Owner: Function;
    // (undocumented)
    setValue(source: HTMLElement, newValue: any): void;
    }

// @public (undocumented)
export type AttributeMode = "reflect" | "boolean" | "fromView";

// @public (undocumented)
export interface Behavior {
    // (undocumented)
    bind(source: unknown, context: ExecutionContext): void;
    // (undocumented)
    unbind(source: unknown): void;
}

// @public (undocumented)
export interface BehaviorFactory {
    // (undocumented)
    createBehavior(target: any): Behavior;
    // (undocumented)
    targetIndex: number;
}

// @public
export type Binding<TSource = any, TReturn = any, TParent = any> = (source: TSource, context: ExecutionContext<TParent>) => TReturn;

// @public
export class BindingBehavior implements Behavior {
    constructor(target: any, binding: Binding, bind: typeof normalBind, unbind: typeof normalUnbind, updateTarget: typeof updatePropertyTarget, targetName?: string | undefined);
    // Warning: (ae-forgotten-export) The symbol "normalBind" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    bind: typeof normalBind;
    // (undocumented)
    binding: Binding;
    // (undocumented)
    bindingObserver: BindingObserver | null;
    // (undocumented)
    classVersions: Record<string, number>;
    // (undocumented)
    context: ExecutionContext | null;
    // @internal (undocumented)
    handleChange(): void;
    // @internal (undocumented)
    handleEvent(event: Event): void;
    // (undocumented)
    source: unknown;
    // (undocumented)
    target: any;
    // (undocumented)
    targetName?: string | undefined;
    // Warning: (ae-forgotten-export) The symbol "normalUnbind" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    unbind: typeof normalUnbind;
    // Warning: (ae-forgotten-export) The symbol "updatePropertyTarget" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    updateTarget: typeof updatePropertyTarget;
    // (undocumented)
    version: number;
}

// @public
export class BindingDirective extends Directive {
    constructor(binding: Binding);
    // (undocumented)
    binding: Binding;
    createBehavior(target: any): BindingBehavior;
    // (undocumented)
    createPlaceholder: (index: number) => string;
    targetAtContent(): void;
    get targetName(): string | undefined;
    set targetName(value: string | undefined);
    }

// @public
export interface BindingObserver<TSource = any, TReturn = any, TParent = any> extends Notifier {
    disconnect(): void;
    observe(source: TSource, context: ExecutionContext): TReturn;
}

// @public (undocumented)
export const booleanConverter: ValueConverter;

// @public
export type Callable = typeof Function.prototype.call | {
    call(): void;
};

// @public
export interface CaptureType<TSource> {
}

// @public (undocumented)
export function children<T = any>(propertyOrOptions: (keyof T & string) | ChildrenBehaviorOptions<keyof T & string>): CaptureType<T>;

// Warning: (ae-forgotten-export) The symbol "NodeObservationBehavior" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class ChildrenBehavior extends NodeObservationBehavior<ChildrenBehaviorOptions> {
    constructor(target: HTMLSlotElement, options: ChildrenBehaviorOptions);
    // (undocumented)
    getNodes(): ChildNode[];
    // (undocumented)
    observe(): void;
    // (undocumented)
    unobserve(): void;
}

// Warning: (ae-forgotten-export) The symbol "NodeBehaviorBehaviorOptions" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export interface ChildrenBehaviorOptions<T = any> extends NodeBehaviorBehaviorOptions<T>, MutationObserverInit {
}

// @public
export interface CompilationResult {
    fragment: DocumentFragment;
    hostBehaviorFactories: BehaviorFactory[];
    targetOffset: number;
    viewBehaviorFactories: BehaviorFactory[];
}

// @public
export function compileTemplate(template: HTMLTemplateElement, directives: ReadonlyArray<Directive>): CompilationResult;

// @public (undocumented)
export class Controller extends PropertyChangeNotifier {
    constructor(element: HTMLElement, definition: FASTElementDefinition);
    // (undocumented)
    addBehaviors(behaviors: ReadonlyArray<Behavior>): void;
    // (undocumented)
    addStyles(styles: ElementStyles, target?: StyleTarget | null): void;
    // (undocumented)
    readonly definition: FASTElementDefinition;
    // (undocumented)
    readonly element: HTMLElement;
    // (undocumented)
    emit(type: string, detail?: any, options?: Omit<CustomEventInit, "detail">): void | boolean;
    // (undocumented)
    static forCustomElement(element: HTMLElement): Controller;
    // (undocumented)
    isConnected: boolean;
    // (undocumented)
    onAttributeChangedCallback(name: string, oldValue: string, newValue: string): void;
    // (undocumented)
    onConnectedCallback(): void;
    // (undocumented)
    onDisconnectedCallback(): void;
    // (undocumented)
    removeBehaviors(behaviors: ReadonlyArray<Behavior>): void;
    // (undocumented)
    removeStyles(styles: ElementStyles): void;
    // (undocumented)
    view: ElementView | null;
}

// Warning: (ae-forgotten-export) The symbol "ElementStyleFactory" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const createStyles: ElementStyleFactory;

// @public (undocumented)
export function css(strings: TemplateStringsArray, ...values: InjectableStyles[]): ElementStyles;

// @public (undocumented)
export function customElement(nameOrDef: string | PartialFASTElementDefinition): (type: Function) => void;

// @public (undocumented)
export type DecoratorAttributeConfiguration = Omit<AttributeConfiguration, "property">;

// @public
export const defaultExecutionContext: ExecutionContext<any>;

// @public (undocumented)
export abstract class Directive implements BehaviorFactory {
    // (undocumented)
    abstract createBehavior(target: any): Behavior;
    // (undocumented)
    abstract createPlaceholder(index: number): string;
    // (undocumented)
    targetIndex: number;
}

// @public
export const DOM: Readonly<{
    setHTMLPolicy(policy: TrustedTypesPolicy): void;
    createHTML(html: string): string;
    isMarker(node: Node): node is Comment;
    extractDirectiveIndexFromMarker(node: Comment): number;
    createInterpolationPlaceholder(index: number): string;
    createCustomAttributePlaceholder(attributeName: string, index: number): string;
    createBlockPlaceholder(index: number): string;
    queueUpdate(callable: Callable): void;
    nextUpdate(): Promise<void>;
    setAttribute(element: HTMLElement, attributeName: string, value: any): void;
    setBooleanAttribute(element: HTMLElement, attributeName: string, value: boolean): void;
}>;

// @public (undocumented)
export abstract class ElementStyles {
    // @internal (undocumented)
    abstract addStylesTo(target: StyleTarget): void;
    // @internal (undocumented)
    abstract readonly behaviors: ReadonlyArray<Behavior> | null;
    // (undocumented)
    static find(key: string): ElementStyles | null;
    // @internal (undocumented)
    abstract removeStylesFrom(target: StyleTarget): void;
    // @internal (undocumented)
    abstract readonly styles: ReadonlyArray<InjectableStyles>;
    // (undocumented)
    withBehaviors(...behaviors: Behavior[]): this;
    // (undocumented)
    withKey(key: string): this;
}

// @public
export interface ElementView extends View {
    appendTo(node: Node): void;
}

// @public
export interface ElementViewTemplate {
    create(host: Element): ElementView;
}

// @public
export const emptyArray: readonly never[];

// @public
export class ExecutionContext<TParent = any> {
    get event(): Event;
    index: number;
    get isEven(): boolean;
    get isFirst(): boolean;
    get isInMiddle(): boolean;
    get isLast(): boolean;
    get isOdd(): boolean;
    length: number;
    parent: TParent;
}

// @public (undocumented)
export interface FASTElement {
    // (undocumented)
    $emit(type: string, detail?: any, options?: Omit<CustomEventInit, "detail">): boolean | void;
    // (undocumented)
    $fastController: Controller;
    // (undocumented)
    attributeChangedCallback(name: string, oldValue: string, newValue: string): void;
    // (undocumented)
    connectedCallback(): void;
    // (undocumented)
    disconnectedCallback(): void;
}

// @public (undocumented)
export const FASTElement: (new () => HTMLElement & FASTElement) & {
    from<TBase extends {
        new (): HTMLElement;
        prototype: HTMLElement;
    }>(BaseType: TBase): new () => InstanceType<TBase> & FASTElement;
    define<TType extends Function>(Type: TType, nameOrDef?: string | PartialFASTElementDefinition): TType;
    getDefinition: typeof getDefinition;
};

// @public (undocumented)
export class FASTElementDefinition {
    constructor(name: string, attributes: ReadonlyArray<AttributeDefinition>, propertyLookup: Record<string, AttributeDefinition>, attributeLookup: Record<string, AttributeDefinition>, template?: ElementViewTemplate | undefined, styles?: ElementStyles | undefined, shadowOptions?: ShadowRootInit | undefined, elementOptions?: ElementDefinitionOptions | undefined);
    // (undocumented)
    readonly attributeLookup: Record<string, AttributeDefinition>;
    // (undocumented)
    readonly attributes: ReadonlyArray<AttributeDefinition>;
    // (undocumented)
    readonly elementOptions?: ElementDefinitionOptions | undefined;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly propertyLookup: Record<string, AttributeDefinition>;
    // (undocumented)
    readonly shadowOptions?: ShadowRootInit | undefined;
    // (undocumented)
    readonly styles?: ElementStyles | undefined;
    // (undocumented)
    readonly template?: ElementViewTemplate | undefined;
}

// @public
export function html<TSource = any, TParent = any>(strings: TemplateStringsArray, ...values: TemplateValue<TSource, TParent>[]): ViewTemplate<TSource, TParent>;

// @public
export class HTMLView implements ElementView, SyntheticView {
    constructor(fragment: DocumentFragment, behaviors: Behavior[]);
    appendTo(node: Node): void;
    bind(source: unknown, context: ExecutionContext): void;
    // (undocumented)
    context: ExecutionContext | null;
    dispose(): void;
    static disposeContiguousBatch(views: SyntheticView[]): void;
    // (undocumented)
    firstChild: Node;
    insertBefore(node: Node): void;
    // (undocumented)
    lastChild: Node;
    remove(): void;
    // (undocumented)
    source: any | null;
    unbind(): void;
}

// @public
export interface Notifier {
    notify(args: any): void;
    readonly source: any;
    subscribe(subscriber: Subscriber, propertyToWatch?: any): void;
    unsubscribe(subscriber: Subscriber, propertyToUnwatch?: any): void;
}

// @public (undocumented)
export const nullableNumberConverter: ValueConverter;

// @public
export const Observable: Readonly<{
    setArrayObserverFactory(factory: (collection: any[]) => Notifier): void;
    getNotifier(source: any): Notifier;
    track(source: unknown, propertyName: string): void;
    notify(source: unknown, args: any): void;
    defineProperty(target: {}, nameOrAccessor: string | Accessor): void;
    getAccessors(target: {}): Accessor[];
    binding<TScope = any, TReturn = any, TParent = any>(binding: Binding<any, any, any>): BindingObserver<TScope, TReturn, TParent>;
}>;

// @public
export function observable(target: {}, nameOrAccessor: string | Accessor): void;

// @public (undocumented)
export type PartialFASTElementDefinition = {
    readonly name: string;
    readonly template?: ElementViewTemplate;
    readonly styles?: ElementStyles;
    readonly attributes?: (AttributeConfiguration | string)[];
    readonly shadowOptions?: Partial<ShadowRootInit> | null;
    readonly elementOptions?: ElementDefinitionOptions;
};

// @public
export class PropertyChangeNotifier implements Notifier {
    constructor(source: any);
    notify(propertyName: string): void;
    // (undocumented)
    readonly source: any;
    subscribe(subscriber: Subscriber, propertyToWatch: string): void;
    unsubscribe(subscriber: Subscriber, propertyToUnwatch: string): void;
}

// @public (undocumented)
export function ref<T = any>(propertyName: keyof T & string): CaptureType<T>;

// @public (undocumented)
export class RefBehavior implements Behavior {
    constructor(target: HTMLElement, propertyName: string);
    // (undocumented)
    bind(source: any): void;
    // (undocumented)
    unbind(): void;
}

// @public (undocumented)
export function repeat<TScope = any, TItem = any>(binding: Binding<TScope, TItem[]>, template: ViewTemplate<Partial<TItem>, TScope>, options?: RepeatOptions): CaptureType<TScope>;

// @public (undocumented)
export class RepeatBehavior implements Behavior, Subscriber {
    constructor(location: Node, binding: Binding, template: SyntheticViewTemplate, options: RepeatOptions);
    // (undocumented)
    bind(source: unknown, context: ExecutionContext): void;
    // Warning: (ae-forgotten-export) The symbol "Splice" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    handleChange(source: any, args: Splice[]): void;
    // (undocumented)
    unbind(): void;
    }

// @public (undocumented)
export class RepeatDirective extends Directive {
    constructor(binding: Binding, template: SyntheticViewTemplate, options: RepeatOptions);
    // (undocumented)
    binding: Binding;
    // (undocumented)
    createBehavior(target: any): RepeatBehavior;
    // (undocumented)
    createPlaceholder: (index: number) => string;
    // (undocumented)
    options: RepeatOptions;
    // (undocumented)
    template: SyntheticViewTemplate;
}

// @public (undocumented)
export interface RepeatOptions {
    // (undocumented)
    positioning: boolean;
}

// Warning: (ae-internal-missing-underscore) The name "setCurrentEvent" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function setCurrentEvent(event: Event | null): void;

// @public (undocumented)
export function slotted<T = any>(propertyOrOptions: (keyof T & string) | SlottedBehaviorOptions<keyof T & string>): CaptureType<T>;

// @public (undocumented)
export class SlottedBehavior extends NodeObservationBehavior<SlottedBehaviorOptions> {
    constructor(target: HTMLSlotElement, options: SlottedBehaviorOptions);
    // (undocumented)
    getNodes(): Node[];
    // (undocumented)
    observe(): void;
    // (undocumented)
    unobserve(): void;
}

// @public (undocumented)
export interface SlottedBehaviorOptions<T = any> extends NodeBehaviorBehaviorOptions<T>, AssignedNodesOptions {
}

// @public (undocumented)
export class StyleElementStyles extends ElementStyles {
    constructor(styles: InjectableStyles[]);
    // (undocumented)
    addStylesTo(target: StyleTarget): void;
    // (undocumented)
    readonly behaviors: ReadonlyArray<Behavior> | null;
    // (undocumented)
    removeStylesFrom(target: StyleTarget): void;
    // (undocumented)
    styles: InjectableStyles[];
    }

// @public (undocumented)
export interface StyleTarget {
    // (undocumented)
    adoptedStyleSheets?: CSSStyleSheet[];
    // (undocumented)
    prepend(node: Node): void;
    // (undocumented)
    querySelectorAll<E extends Element = Element>(selectors: string): NodeListOf<E>;
    // (undocumented)
    removeChild(node: Node): void;
}

// @public
export interface Subscriber {
    handleChange(source: any, args: any): void;
}

// @public
export class SubscriberSet implements Notifier {
    constructor(source: any);
    has(subscriber: Subscriber): boolean;
    notify(args: any): void;
    // (undocumented)
    readonly source: any;
    subscribe(subscriber: Subscriber): void;
    unsubscribe(subscriber: Subscriber): void;
}

// @public
export interface SyntheticView extends View {
    dispose(): void;
    readonly firstChild: Node;
    insertBefore(node: Node): void;
    readonly lastChild: Node;
    remove(): void;
}

// @public
export interface SyntheticViewTemplate<TSource = any, TParent = any> {
    create(): SyntheticView;
}

// @public
export type TemplateValue<TScope, TParent = any> = Binding<TScope, any, TParent> | string | number | Directive | CaptureType<TScope>;

// @public (undocumented)
export interface ValueConverter {
    // (undocumented)
    fromView(value: string): any;
    // (undocumented)
    toView(value: any): string | null;
}

// @public
export interface View {
    bind(source: unknown, context: ExecutionContext): void;
    readonly context: ExecutionContext | null;
    readonly source: any | null;
    unbind(): void;
}

// @public
export class ViewTemplate<TSource = any, TParent = any> implements ElementViewTemplate, SyntheticViewTemplate {
    constructor(html: string | HTMLTemplateElement, directives: ReadonlyArray<Directive>);
    create(host?: Element): HTMLView;
    // (undocumented)
    readonly directives: ReadonlyArray<Directive>;
    // (undocumented)
    readonly html: string | HTMLTemplateElement;
    render(source: TSource, host: HTMLElement | string): HTMLView;
    }

// @public
export function when<TSource = any, TReturn = any>(binding: Binding<TSource, TReturn>, templateOrTemplateBinding: SyntheticViewTemplate | Binding<TSource, SyntheticViewTemplate>): CaptureType<TSource>;


// Warnings were encountered during analysis:
//
// dist/dts/dom.d.ts:9:5 - (ae-forgotten-export) The symbol "TrustedTypesPolicy" needs to be exported by the entry point index.d.ts
// dist/dts/fast-element.d.ts:16:5 - (ae-forgotten-export) The symbol "getDefinition" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
