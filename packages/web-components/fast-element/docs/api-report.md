## API Report File for "@microsoft/fast-element"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export const $global: Global;

// @public
export interface Accessor {
    getValue(source: any): any;
    name: string;
    setValue(source: any, value: any): void;
}

// @public
export abstract class AspectedHTMLDirective extends HTMLDirective {
    createPlaceholder: (index: number) => string;
    // (undocumented)
    abstract setAspect(value: string): void;
}

// @public
export function attr(config?: DecoratorAttributeConfiguration): (target: {}, property: string) => void;

// @public
export function attr(target: {}, prop: string): void;

// @public
export type AttributeConfiguration = {
    property: string;
    attribute?: string;
    mode?: AttributeMode;
    converter?: ValueConverter;
};

// @public
export class AttributeDefinition implements Accessor {
    constructor(Owner: Function, name: string, attribute?: string, mode?: AttributeMode, converter?: ValueConverter);
    readonly attribute: string;
    // @internal
    static collect(Owner: Function, ...attributeLists: (ReadonlyArray<string | AttributeConfiguration> | undefined)[]): ReadonlyArray<AttributeDefinition>;
    readonly converter?: ValueConverter;
    getValue(source: HTMLElement): any;
    readonly mode: AttributeMode;
    readonly name: string;
    // @internal (undocumented)
    onAttributeChangedCallback(element: HTMLElement, value: any): void;
    readonly Owner: Function;
    setValue(source: HTMLElement, newValue: any): void;
    }

// @public
export type AttributeMode = "reflect" | "boolean" | "fromView";

// @public
export interface Behavior<TSource = any, TParent = any, TGrandparent = any> {
    bind(source: TSource, context: ExecutionContext<TParent, TGrandparent>): void;
    unbind(source: TSource, context: ExecutionContext<TParent, TGrandparent>): void;
}

// @alpha (undocumented)
export function bind<T = any>(binding: Binding<T>, config?: BindingConfig<T> | DefaultBindingOptions): CaptureType<T>;

// @public
export type Binding<TSource = any, TReturn = any, TParent = any> = (source: TSource, context: ExecutionContext<TParent>) => TReturn;

// @alpha (undocumented)
export type BindingBehaviorFactory = {
    createBehavior(targets: ViewBehaviorTargets): ViewBehavior;
};

// @alpha (undocumented)
export interface BindingConfig<T = any> {
    // (undocumented)
    mode: BindingMode;
    // (undocumented)
    options: any;
}

// @alpha (undocumented)
export interface BindingMode {
    // (undocumented)
    attribute: BindingType;
    // (undocumented)
    booleanAttribute: BindingType;
    // (undocumented)
    content: BindingType;
    // (undocumented)
    event: BindingType;
    // (undocumented)
    property: BindingType;
    // (undocumented)
    tokenList: BindingType;
}

// @public
export interface BindingObserver<TSource = any, TReturn = any, TParent = any> extends Notifier {
    disconnect(): void;
    observe(source: TSource, context: ExecutionContext): TReturn;
    records(): IterableIterator<ObservationRecord>;
}

// Warning: (ae-forgotten-export) The symbol "HTMLBindingDirective" needs to be exported by the entry point index.d.ts
//
// @alpha (undocumented)
export type BindingType = (directive: HTMLBindingDirective) => BindingBehaviorFactory;

// @public
export const booleanConverter: ValueConverter;

// @public
export type Callable = typeof Function.prototype.call | {
    call(): void;
};

// @public
export interface CaptureType<TSource> {
}

// @public
export interface ChildListDirectiveOptions<T = any> extends NodeBehaviorOptions<T>, Omit<MutationObserverInit, "subtree" | "childList"> {
}

// @public
export function children<T = any>(propertyOrOptions: (keyof T & string) | ChildListDirectiveOptions<keyof T & string>): CaptureType<T>;

// Warning: (ae-forgotten-export) The symbol "NodeObservationDirective" needs to be exported by the entry point index.d.ts
//
// @public
export class ChildrenDirective extends NodeObservationDirective<ChildrenDirectiveOptions> {
    constructor(options: ChildrenDirectiveOptions);
    disconnect(target: any): void;
    getNodes(target: Element): Node[];
    observe(target: any): void;
}

// @public
export type ChildrenDirectiveOptions<T = any> = ChildListDirectiveOptions<T> | SubtreeDirectiveOptions<T>;

// @public
export function compileTemplate(template: HTMLTemplateElement, directives: ReadonlyArray<HTMLDirective>): HTMLTemplateCompilationResult;

// @public
export type ComposableStyles = string | ElementStyles | CSSStyleSheet;

// @public
export type Constructable<T = {}> = {
    new (...args: any[]): T;
};

// @public
export type ConstructibleStyleStrategy = {
    new (styles: (string | CSSStyleSheet)[]): StyleStrategy;
};

// @public
export class Controller extends PropertyChangeNotifier {
    // @internal
    constructor(element: HTMLElement, definition: FASTElementDefinition);
    addBehaviors(behaviors: ReadonlyArray<Behavior<HTMLElement>>): void;
    addStyles(styles: ElementStyles | HTMLStyleElement): void;
    readonly definition: FASTElementDefinition;
    readonly element: HTMLElement;
    emit(type: string, detail?: any, options?: Omit<CustomEventInit, "detail">): void | boolean;
    static forCustomElement(element: HTMLElement): Controller;
    get isConnected(): boolean;
    onAttributeChangedCallback(name: string, oldValue: string | null, newValue: string | null): void;
    onConnectedCallback(): void;
    onDisconnectedCallback(): void;
    removeBehaviors(behaviors: ReadonlyArray<Behavior<HTMLElement>>, force?: boolean): void;
    removeStyles(styles: ElementStyles | HTMLStyleElement): void;
    get styles(): ElementStyles | null;
    set styles(value: ElementStyles | null);
    get template(): ElementViewTemplate | null;
    set template(value: ElementViewTemplate | null);
    readonly view: ElementView | null;
}

// @public
export function css(strings: TemplateStringsArray, ...values: (ComposableStyles | CSSDirective)[]): ElementStyles;

// @public
export class CSSDirective {
    createBehavior(): Behavior<HTMLElement> | undefined;
    createCSS(): ComposableStyles;
}

// @public
export function cssPartial(strings: TemplateStringsArray, ...values: (ComposableStyles | CSSDirective)[]): CSSDirective;

// @public
export function customElement(nameOrDef: string | PartialFASTElementDefinition): (type: Function) => void;

// @public
export type DecoratorAttributeConfiguration = Omit<AttributeConfiguration, "property">;

// @alpha (undocumented)
export type DefaultBindingOptions = {
    capture?: boolean;
};

// @public
export const defaultExecutionContext: ExecutionContext<any, any>;

// @public
export const DOM: Readonly<{
    supportsAdoptedStyleSheets: boolean;
    setHTMLPolicy(policy: TrustedTypesPolicy): void;
    createHTML(html: string): string;
    setUpdateMode(isAsync: boolean): void;
    queueUpdate(callable: Callable): void;
    nextUpdate(): Promise<void>;
    processUpdates(): void;
    setAttribute(element: HTMLElement, attributeName: string, value: any): void;
    setBooleanAttribute(element: HTMLElement, attributeName: string, value: boolean): void;
}>;

// @public
export const elements: (selector?: string | undefined) => ElementsFilter;

// @public
export type ElementsFilter = (value: Node, index: number, array: Node[]) => boolean;

// @public
export class ElementStyles {
    constructor(
    styles: ReadonlyArray<ComposableStyles>);
    // @internal (undocumented)
    addStylesTo(target: StyleTarget): void;
    // @internal (undocumented)
    readonly behaviors: ReadonlyArray<Behavior<HTMLElement>> | null;
    // @internal (undocumented)
    isAttachedTo(target: StyleTarget): boolean;
    // @internal (undocumented)
    removeStylesFrom(target: StyleTarget): void;
    static setDefaultStrategy(Strategy: ConstructibleStyleStrategy): void;
    get strategy(): StyleStrategy;
    // @internal (undocumented)
    readonly styles: ReadonlyArray<ComposableStyles>;
    withBehaviors(...behaviors: Behavior<HTMLElement>[]): this;
    withStrategy(Strategy: ConstructibleStyleStrategy): this;
}

// @public
export interface ElementView<TSource = any, TParent = any, TGrandparent = any> extends View<TSource, TParent, TGrandparent> {
    appendTo(node: Node): void;
}

// @public
export interface ElementViewTemplate<TSource = any, TParent = any, TGrandparent = any> {
    create(hostBindingTarget: Element): ElementView<TSource, TParent, TGrandparent>;
    render(source: TSource, host: Node, hostBindingTarget?: Element): HTMLView<TSource, TParent, TGrandparent>;
}

// Warning: (ae-internal-missing-underscore) The name "emptyArray" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export const emptyArray: readonly never[];

// @public
export function enableArrayObservation(): void;

// @public
export class ExecutionContext<TParent = any, TGrandparent = any> {
    get event(): Event;
    index: number;
    get isEven(): boolean;
    get isFirst(): boolean;
    get isInMiddle(): boolean;
    get isLast(): boolean;
    get isOdd(): boolean;
    length: number;
    parent: TParent;
    parentContext: ExecutionContext<TGrandparent>;
}

// @public
export interface FASTElement extends HTMLElement {
    $emit(type: string, detail?: any, options?: Omit<CustomEventInit, "detail">): boolean | void;
    readonly $fastController: Controller;
    attributeChangedCallback(name: string, oldValue: string | null, newValue: string | null): void;
    connectedCallback(): void;
    disconnectedCallback(): void;
}

// @public
export const FASTElement: (new () => HTMLElement & FASTElement) & {
    from<TBase extends {
        new (): HTMLElement;
        prototype: HTMLElement;
    }>(BaseType: TBase): new () => InstanceType<TBase> & FASTElement;
    define<TType extends Function>(type: TType, nameOrDef?: string | PartialFASTElementDefinition | undefined): TType;
};

// @public
export class FASTElementDefinition<TType extends Function = Function> {
    constructor(type: TType, nameOrConfig?: PartialFASTElementDefinition | string);
    readonly attributeLookup: Record<string, AttributeDefinition>;
    readonly attributes: ReadonlyArray<AttributeDefinition>;
    define(registry?: CustomElementRegistry): this;
    readonly elementOptions?: ElementDefinitionOptions;
    static forType<TType extends Function>(type: TType): FASTElementDefinition | undefined;
    readonly isDefined: boolean;
    readonly name: string;
    readonly propertyLookup: Record<string, AttributeDefinition>;
    readonly shadowOptions?: ShadowRootInit;
    readonly styles?: ElementStyles;
    readonly template?: ElementViewTemplate;
    readonly type: TType;
}

// @public
export type Global = typeof globalThis & {
    trustedTypes: TrustedTypes;
};

// @public
export function html<TSource = any, TParent = any, TGrandparent = any>(strings: TemplateStringsArray, ...values: TemplateValue<TSource, TParent>[]): ViewTemplate<TSource, TParent, TGrandparent>;

// @public
export abstract class HTMLDirective implements ViewBehaviorFactory {
    abstract createBehavior(targets: ViewBehaviorTargets): Behavior | ViewBehavior;
    abstract createPlaceholder(index: number): string;
    targetId: string;
    readonly uniqueId: string;
}

// @public
export interface HTMLTemplateCompilationResult {
    createTargets(root: Node, host?: Node): ViewBehaviorTargets;
    readonly factories: ReadonlyArray<ViewBehaviorFactory>;
    readonly fragment: DocumentFragment;
}

// @public
export class HTMLView<TSource = any, TParent = any, TGrandparent = any> implements ElementView<TSource, TParent, TGrandparent>, SyntheticView<TSource, TParent, TGrandparent> {
    constructor(fragment: DocumentFragment, factories: ReadonlyArray<ViewBehaviorFactory>, targets: ViewBehaviorTargets);
    appendTo(node: Node): void;
    bind(source: TSource, context: ExecutionContext<TParent, TGrandparent>): void;
    context: ExecutionContext<TParent, TGrandparent> | null;
    dispose(): void;
    static disposeContiguousBatch(views: SyntheticView[]): void;
    firstChild: Node;
    insertBefore(node: Node): void;
    lastChild: Node;
    remove(): void;
    source: TSource | null;
    unbind(): void;
}

// @public
export abstract class InlinableHTMLDirective extends AspectedHTMLDirective {
    // (undocumented)
    abstract readonly binding: Binding;
    // (undocumented)
    abstract readonly rawAspect?: string;
}

// @public
export const Markup: Readonly<{
    marker: string;
    interpolation(index: number): string;
    attribute(index: number): string;
    comment(index: number): string;
    indexFromComment(node: Comment): number;
}>;

// Warning: (ae-internal-missing-underscore) The name "Mutable" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
};

// @public
export interface NodeBehaviorOptions<T = any> {
    filter?: ElementsFilter;
    property: T;
}

// @public
export interface Notifier {
    notify(args: any): void;
    readonly subject: any;
    subscribe(subscriber: Subscriber, propertyToWatch?: any): void;
    unsubscribe(subscriber: Subscriber, propertyToUnwatch?: any): void;
}

// @public
export const nullableNumberConverter: ValueConverter;

// @public
export const Observable: Readonly<{
    setArrayObserverFactory(factory: (collection: any[]) => Notifier): void;
    getNotifier(source: any): Notifier;
    track(source: unknown, propertyName: string): void;
    trackVolatile(): void;
    notify(source: unknown, args: any): void;
    defineProperty(target: {}, nameOrAccessor: string | Accessor): void;
    getAccessors(target: {}): Accessor[];
    binding<TSource = any, TReturn = any, TParent = any>(binding: Binding<TSource, TReturn, TParent>, initialSubscriber?: Subscriber | undefined, isVolatileBinding?: boolean): BindingObserver<TSource, TReturn, TParent>;
    isVolatileBinding<TSource_1 = any, TReturn_1 = any, TParent_1 = any>(binding: Binding<TSource_1, TReturn_1, TParent_1>): boolean;
}>;

// @public
export function observable(target: {}, nameOrAccessor: string | Accessor): void;

// @public
export interface ObservationRecord {
    propertyName: string;
    propertySource: any;
}

// Warning: (ae-forgotten-export) The symbol "BindingConfigResolver" needs to be exported by the entry point index.d.ts
//
// @alpha (undocumented)
export const onChange: BindingConfig<DefaultBindingOptions> & BindingConfigResolver<DefaultBindingOptions>;

// @alpha (undocumented)
export const oneTime: BindingConfig<DefaultBindingOptions> & BindingConfigResolver<DefaultBindingOptions>;

// @public
export const Parser: Readonly<{
    parse(value: string, directives: readonly HTMLDirective[]): (string | HTMLDirective)[] | null;
    aggregate(parts: (string | HTMLDirective)[]): InlinableHTMLDirective;
}>;

// @public
export interface PartialFASTElementDefinition {
    readonly attributes?: (AttributeConfiguration | string)[];
    readonly elementOptions?: ElementDefinitionOptions;
    readonly name: string;
    readonly shadowOptions?: Partial<ShadowRootInit> | null;
    readonly styles?: ComposableStyles | ComposableStyles[];
    readonly template?: ElementViewTemplate;
}

// @public
export class PropertyChangeNotifier implements Notifier {
    constructor(subject: any);
    notify(propertyName: string): void;
    readonly subject: any;
    subscribe(subscriber: Subscriber, propertyToWatch?: string): void;
    unsubscribe(subscriber: Subscriber, propertyToUnwatch?: string): void;
}

// @public
export const ref: <T = any>(propertyName: keyof T & string) => CaptureType<T>;

// Warning: (ae-forgotten-export) The symbol "StatelessAttachedAttributeDirective" needs to be exported by the entry point index.d.ts
//
// @public
export class RefDirective extends StatelessAttachedAttributeDirective<string> {
    bind(source: any, context: ExecutionContext, targets: ViewBehaviorTargets): void;
    unbind(): void;
}

// @public
export function repeat<TSource = any, TItem = any>(itemsBinding: Binding<TSource, readonly TItem[]>, templateOrTemplateBinding: SyntheticViewTemplate | Binding<TSource, SyntheticViewTemplate>, options?: RepeatOptions): CaptureType<TSource>;

// @public
export class RepeatBehavior<TSource = any> implements Behavior, Subscriber {
    constructor(location: Node, itemsBinding: Binding<TSource, any[]>, isItemsBindingVolatile: boolean, templateBinding: Binding<TSource, SyntheticViewTemplate>, isTemplateBindingVolatile: boolean, options: RepeatOptions);
    bind(source: TSource, context: ExecutionContext): void;
    // @internal (undocumented)
    handleChange(source: any, args: Splice[]): void;
    unbind(): void;
    }

// @public
export class RepeatDirective<TSource = any> extends HTMLDirective {
    constructor(itemsBinding: Binding, templateBinding: Binding<TSource, SyntheticViewTemplate>, options: RepeatOptions);
    createBehavior(targets: ViewBehaviorTargets): RepeatBehavior<TSource>;
    createPlaceholder: (index: number) => string;
    }

// @public
export interface RepeatOptions {
    positioning?: boolean;
    recycle?: boolean;
}

// Warning: (ae-internal-missing-underscore) The name "setCurrentEvent" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function setCurrentEvent(event: Event | null): void;

// @public
export function slotted<T = any>(propertyOrOptions: (keyof T & string) | SlottedDirectiveOptions<keyof T & string>): CaptureType<T>;

// @public
export class SlottedDirective extends NodeObservationDirective<SlottedDirectiveOptions> {
    disconnect(target: EventSource): void;
    getNodes(target: HTMLSlotElement): Node[];
    // @internal (undocumented)
    handleEvent(event: Event): void;
    observe(target: EventSource): void;
}

// @public
export interface SlottedDirectiveOptions<T = any> extends NodeBehaviorOptions<T>, AssignedNodesOptions {
}

// @public
export class Splice {
    constructor(
    index: number,
    removed: any[],
    addedCount: number);
    addedCount: number;
    index: number;
    // (undocumented)
    static normalize(previous: unknown[] | undefined, current: unknown[], changes: Splice[] | undefined): Splice[] | undefined;
    removed: any[];
}

// @public
export interface StyleStrategy {
    addStylesTo(target: StyleTarget): void;
    removeStylesFrom(target: StyleTarget): void;
}

// @public
export interface StyleTarget {
    adoptedStyleSheets?: CSSStyleSheet[];
    append(styles: HTMLStyleElement): void;
    querySelectorAll<E extends Element = Element>(selectors: string): NodeListOf<E>;
    removeChild(styles: HTMLStyleElement): void;
}

// @public
export interface Subscriber {
    handleChange(subject: any, args: any): void;
}

// @public
export class SubscriberSet implements Notifier {
    constructor(subject: any, initialSubscriber?: Subscriber);
    has(subscriber: Subscriber): boolean;
    notify(args: any): void;
    readonly subject: any;
    subscribe(subscriber: Subscriber): void;
    unsubscribe(subscriber: Subscriber): void;
}

// @public
export interface SubtreeDirectiveOptions<T = any> extends Omit<NodeBehaviorOptions<T>, "filter">, Omit<MutationObserverInit, "subtree" | "childList"> {
    selector: string;
    subtree: boolean;
}

// @public
export interface SyntheticView<TSource = any, TParent = any, TGrandparent = any> extends View<TSource, TParent, TGrandparent> {
    dispose(): void;
    readonly firstChild: Node;
    insertBefore(node: Node): void;
    readonly lastChild: Node;
    remove(): void;
}

// @public
export interface SyntheticViewTemplate<TSource = any, TParent = any, TGrandparent = any> {
    create(): SyntheticView<TSource, TParent, TGrandparent>;
}

// @public
export type TemplateValue<TSource, TParent = any> = Binding<TSource, any, TParent> | HTMLDirective | CaptureType<TSource>;

// @public
export type TrustedTypes = {
    createPolicy(name: string, rules: TrustedTypesPolicy): TrustedTypesPolicy;
};

// @public
export type TrustedTypesPolicy = {
    createHTML(html: string): string;
};

// @public
export interface ValueConverter {
    fromView(value: any): any;
    toView(value: any): any;
}

// @public
export interface View<TSource = any, TParent = any, TGrandparent = any> {
    bind(source: TSource, context: ExecutionContext<TParent, TGrandparent>): void;
    readonly context: ExecutionContext<TParent, TGrandparent> | null;
    dispose(): void;
    readonly source: TSource | null;
    unbind(): void;
}

// @public
export interface ViewBehavior<TSource = any, TParent = any, TGrandparent = any> {
    bind(source: TSource, context: ExecutionContext<TParent, TGrandparent>, targets: ViewBehaviorTargets): void;
    unbind(source: TSource, context: ExecutionContext<TParent, TGrandparent>, targets: ViewBehaviorTargets): void;
}

// @public
export interface ViewBehaviorFactory {
    createBehavior(targets: ViewBehaviorTargets): Behavior | ViewBehavior;
    targetId: string;
}

// @public
export type ViewBehaviorTargets = {
    [id: string]: Node;
};

// @public
export class ViewTemplate<TSource = any, TParent = any, TGrandparent = any> implements ElementViewTemplate<TSource, TParent, TGrandparent>, SyntheticViewTemplate<TSource, TParent, TGrandparent> {
    constructor(html: string | HTMLTemplateElement, directives: ReadonlyArray<HTMLDirective>);
    create(hostBindingTarget?: Element): HTMLView<TSource, TParent, TGrandparent>;
    readonly directives: ReadonlyArray<HTMLDirective>;
    readonly html: string | HTMLTemplateElement;
    render(source: TSource, host: Node, hostBindingTarget?: Element): HTMLView<TSource, TParent, TGrandparent>;
    }

// @public
export function volatile(target: {}, name: string | Accessor, descriptor: PropertyDescriptor): PropertyDescriptor;

// @public
export function when<TSource = any, TReturn = any>(binding: Binding<TSource, TReturn>, templateOrTemplateBinding: SyntheticViewTemplate | Binding<TSource, SyntheticViewTemplate>): CaptureType<TSource>;


// (No @packageDocumentation comment for this package)

```
