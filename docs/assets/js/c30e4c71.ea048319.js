"use strict";(self.webpackChunk_microsoft_fast_site=self.webpackChunk_microsoft_fast_site||[]).push([[44675],{33444:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var o=t(31085),i=t(71184);const s={id:"creating-a-component-library",title:"Creating a Component Library",sidebar_label:"Creating a Component Library",custom_edit_url:"https://github.com/microsoft/fast/edit/main/sites/website/versioned_docs/version-legacy/design-systems/creating-a-component-library.md",description:"Not only is FAST great for creating individual components, but it also shines when creating libraries or systems of components.",keywords:["foundation components","design systems"]},a=void 0,r={id:"design-systems/creating-a-component-library",title:"Creating a Component Library",description:"Not only is FAST great for creating individual components, but it also shines when creating libraries or systems of components.",source:"@site/versioned_docs/version-1.x/design-systems/creating-a-component-library.md",sourceDirName:"design-systems",slug:"/design-systems/creating-a-component-library",permalink:"/docs/1.x/design-systems/creating-a-component-library",draft:!1,unlisted:!1,editUrl:"https://github.com/microsoft/fast/edit/main/sites/website/versioned_docs/version-legacy/design-systems/creating-a-component-library.md",tags:[],version:"1.x",frontMatter:{id:"creating-a-component-library",title:"Creating a Component Library",sidebar_label:"Creating a Component Library",custom_edit_url:"https://github.com/microsoft/fast/edit/main/sites/website/versioned_docs/version-legacy/design-systems/creating-a-component-library.md",description:"Not only is FAST great for creating individual components, but it also shines when creating libraries or systems of components.",keywords:["foundation components","design systems"]},sidebar:"docs",previous:{title:"Overview",permalink:"/docs/1.x/design-systems/overview"},next:{title:"Design Tokens",permalink:"/docs/1.x/design-systems/design-tokens"}},c={},l=[{value:"Defining components",id:"defining-components",level:2},{value:"Define Templates and Styles",id:"define-templates-and-styles",level:3},{value:"What is the <code>ElementDefinitionContext</code>?",id:"what-is-the-elementdefinitioncontext",level:4},{value:"What is the <code>FoundationElementDefinition</code>?",id:"what-is-the-foundationelementdefinition",level:4},{value:"Compose and Export Registration",id:"compose-and-export-registration",level:3},{value:"Registering Library Components in an Application",id:"registering-library-components-in-an-application",level:3},{value:"Defining a design system",id:"defining-a-design-system",level:2},{value:"FAST design system thinking",id:"fast-design-system-thinking",level:3},{value:"Composing a foundation component",id:"composing-a-foundation-component",level:3},{value:"Creating a design system provider function",id:"creating-a-design-system-provider-function",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"Not only is FAST great for creating individual components, but it also shines when creating libraries or systems of components. FAST Foundation exposes several powerful abstractions in order to enable library authors to provide ergonomic APIs to application authors. These APIs ensure that app authors who consume your library have a consistent way to configure, augment, and override various details of the components. For example:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Custom element tag names are easily configured and disambiguated."}),"\n",(0,o.jsx)(n.li,{children:"Custom elements are explicitly registered to avoid tree-shaking."}),"\n",(0,o.jsx)(n.li,{children:"Templates, styles, default slotted content, and arbitrary component configurations are all configurable by application authors."}),"\n",(0,o.jsx)(n.li,{children:"Shadow DOM options are easily configurable."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"All these configuration capabilities are designed to give application authors the flexibility necessary to align library components to application or business requirements. This section walks through the process of defining a component from a library author\u2019s perspective, detailing component, template, and style creation that supports the configuration capabilities described above."}),"\n",(0,o.jsx)(n.h2,{id:"defining-components",children:"Defining components"}),"\n",(0,o.jsxs)(n.p,{children:["To opt into the features above, begin by extending your components from the ",(0,o.jsx)(n.code,{children:"FoundationElement"})," base class in ",(0,o.jsx)(n.code,{children:"@microsoft/fast-foundation"})," rather than ",(0,o.jsx)(n.code,{children:"FASTElement"}),". ",(0,o.jsx)(n.code,{children:"FoundationElement"})," is a light extension of ",(0,o.jsx)(n.code,{children:"FASTElement"})," that supports element configuration during component registration as well as DOM-scoped, overridable templates and styles. Here's an example of a basic ",(0,o.jsx)(n.code,{children:"Counter"})," component that inherits from ",(0,o.jsx)(n.code,{children:"FoundationElement"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { FoundationElement } from "@microsoft/fast-foundation";\nimport { attr } from "@microsoft/fast-element";\n\nexport class Counter extends FoundationElement {\n    @attr count = 0;\n\n    increment() {\n        this.count++;\n    }\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["One important detail to note is that we do not use the ",(0,o.jsx)(n.code,{children:"@customElement"})," decorator in this case. The ",(0,o.jsx)(n.code,{children:"@customElement"})," decorator forces immediate template and style resolution, and platform component element name registration. This is fine when building application components, or components not intended to be used as part of a library in another application. However, if used for library components, it prevents the consumer of the component from having the opportunity to customize the component in ways that might be critical for their app. ",(0,o.jsx)(n.code,{children:"FoundationElement"})," helps address this challenge."]}),"\n",(0,o.jsx)(n.h3,{id:"define-templates-and-styles",children:"Define Templates and Styles"}),"\n",(0,o.jsxs)(n.p,{children:["With our ",(0,o.jsx)(n.code,{children:"Counter"})," component class written, we now need to define its templates and styles. There are two ways to accomplish this. Just like ",(0,o.jsx)(n.code,{children:"FASTElement"}),", a component that extends ",(0,o.jsx)(n.code,{children:"FoundationElement"})," can be used with the ",(0,o.jsx)(n.a,{href:"/docs/1.x/fast-element/declaring-templates",children:(0,o.jsx)(n.code,{children:"html"})})," and ",(0,o.jsx)(n.a,{href:"/docs/1.x/fast-element/leveraging-css",children:(0,o.jsx)(n.code,{children:"css"})})," tagged template literals. So, we could define our template and styles in the same fashion as any other component, like this:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { html, css  } from "@microsoft/fast-element";\n\nconst counterStyles = css`/* ... */`;\nconst counterTemplate = html`\x3c!-- ... --\x3e`;\n'})}),"\n",(0,o.jsxs)(n.p,{children:["However, a ",(0,o.jsx)(n.code,{children:"FoundationElement"})," also supports a lazily-defined template and style type. This lazy option is a function invoked with ",(0,o.jsx)(n.a,{href:"/docs/1.x/api/fast-foundation.elementdefinitioncontext",children:"ElementDefinitionContext"})," and ",(0,o.jsx)(n.a,{href:"/docs/1.x/api/fast-foundation.foundationelementdefinition",children:"FoundationElementDefinition"})," options, providing opportunity to adjust the template or styles based on how the element or other elements are defined. Lazy template and style definitions provide incredible flexibility and are what can allow application authors to re-name component tag names, override default slotted content, and communicate any component-specific configuration options. Here's how we would convert the previous standard templates and styles into lazy templates and styles:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { html, css  } from "@microsoft/fast-element";\nimport { ElementDefinitionContext, FoundationElementDefinition } from "@microsoft/fast-foundation";\n\nconst counterStyles = (\n    context: ElementDefinitionContext,\n    definition: FoundationElementDefinition\n) => css`/* ... */`;\n\nconst counterTemplate = (\n    context: ElementDefinitionContext,\n    definition: FoundationElementDefinition\n) => html`\x3c!-- ... --\x3e`;\n'})}),"\n",(0,o.jsx)(n.p,{children:"Let\u2019s take a closer look at what the two arguments to these lazily evaluated functions give us."}),"\n",(0,o.jsxs)(n.h4,{id:"what-is-the-elementdefinitioncontext",children:["What is the ",(0,o.jsx)(n.code,{children:"ElementDefinitionContext"}),"?"]}),"\n",(0,o.jsxs)(n.p,{children:["The first argument is the ",(0,o.jsx)(n.code,{children:"ElementDefinitionContext"}),". This context object provides information that is available ",(0,o.jsx)(n.em,{children:"during"})," the attempt to register the element. For example, it will tell you the HTML element tag ",(0,o.jsx)(n.code,{children:"name"})," that the component will be defined as. You can also see what the default ",(0,o.jsx)(n.code,{children:"shadowRootMode"})," of the ",(0,o.jsx)(n.code,{children:"DesignSystem"})," is. Most of the other APIs are used internally by ",(0,o.jsx)(n.code,{children:"FoundationElement.compose"})," (see below) to define the element, but one particular API of note is the ",(0,o.jsx)(n.code,{children:"tagFor()"})," method of the context. This API is used to inspect the tag-name of other components and allows usage of other library components in a template or stylesheet without knowing ahead of time what the tag-name for the element will be. Here's an example of how the reusable ",(0,o.jsx)(n.code,{children:"Counter"})," component would leverage this to ensure that the ",(0,o.jsx)(n.code,{children:"Button"}),"'s tag name is correct, even if the app developer decides to rename ",(0,o.jsx)(n.code,{children:"Button"})," in some way."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { html, css } from "@microsoft/fast-element";\nimport { Button } from "@microsoft/fast-components";\nimport type { ElementDefinitionContext } from "@microsoft/fast-foundation";\n\nconst counterTemplate = (context: ElementDefinitionContext) => {\n    const buttonTag = context.tagFor(Button);\n\n    return html`\n        <div>The count is ${x => x.count}.</div>\n        <${buttonTag} @click=${x => x.increment()}>Count!</${buttonTag}>\n    `;\n}\n\nconst counterStyles = (context: ElementDefinitionContext) => {\n    const buttonTag = context.tagFor(Button);\n\n    return css`\n        ${buttonTag} {\n            margin-inline-start: 12px;\n        }\n    `;\n}\n'})}),"\n",(0,o.jsxs)(n.h4,{id:"what-is-the-foundationelementdefinition",children:["What is the ",(0,o.jsx)(n.code,{children:"FoundationElementDefinition"}),"?"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"FoundationElementDefinition"})," is the configuration for the element itself. This argument allows you to inspect the aggregated options configured for the component, giving you access to the ",(0,o.jsx)(n.code,{children:"shadowOptions"}),", ",(0,o.jsx)(n.code,{children:"elementOptions"}),", and more."]}),"\n",(0,o.jsxs)(n.p,{children:["This definition can also be arbitrarily extended by library authors, allowing custom configuration to flow through the registration process. For example, this mechanism can facilitate default slotted content overrides. To see how our ",(0,o.jsx)(n.code,{children:"Counter"})," could leverage this, let's enable the ",(0,o.jsx)(n.code,{children:"Button"})," content to be overridden by the application developer. Here's what that would look like:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { html } from "@microsoft/fast-element";\nimport { ElementDefinitionContext, FoundationElementDefinition } from "@microsoft/fast-foundation";\nimport { Button } from "@microsoft/fast-components";\n\n// Extend the configuration with custom properties\ninterface CounterDefinition extends FoundationElementDefinition {\n    defaultButtonContent?: string;\n}\n\nconst counterTemplate = (context: ElementDefinitionContext, definition: CounterDefinition) => {\n    const buttonTag = context.tagFor(Button);\n\n    return html`\n        <div>The count is ${x => x.count}.</div>\n        <${buttonTag} @click=${x => x.increment()}>\n            <slot>${definition.defaultButtonContent}</slot> \x3c!--Use the custom configuration--\x3e\n        </${buttonTag}>\n    `;\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["When the library author creates the registration function (see next section), they can provide the default content. Then, during component registration with the ",(0,o.jsx)(n.code,{children:"DesignSystem"}),", an application author can optionally provide a ",(0,o.jsx)(n.code,{children:"defaultButtonContent"})," field as a configuration to override this setting."]}),"\n",(0,o.jsx)(n.h3,{id:"compose-and-export-registration",children:"Compose and Export Registration"}),"\n",(0,o.jsxs)(n.p,{children:["The final step in the process is to create and export the registration function so that application authors can register the component in their ",(0,o.jsx)(n.code,{children:"DesignSystem"}),". Here's how we would create the registration function for ",(0,o.jsx)(n.code,{children:"Counter"}),", using our extended ",(0,o.jsx)(n.code,{children:"CounterDefinition"})," configuration:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"export const counter = Counter.compose<CounterDefinition>({\n    baseName: 'counter',\n    template,\n    styles,\n    defaultButtonContent: \"Count!\"\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Here we provide the base component name of ",(0,o.jsx)(n.code,{children:"counter"}),", which will be combined with the ",(0,o.jsx)(n.code,{children:"DesignSystem"})," element prefix during registration. We also provide our lazy template and styles. Finally, we specify the ",(0,o.jsx)(n.code,{children:"defaultButtonContent"})," value."]}),"\n",(0,o.jsx)(n.h3,{id:"registering-library-components-in-an-application",children:"Registering Library Components in an Application"}),"\n",(0,o.jsxs)(n.p,{children:["To register the component, an application author will import the registration and register it in their ",(0,o.jsx)(n.code,{children:"DesignSystem"}),", overriding any properties as necessary. For example, if this component had been created for the FAST Frame design system, then the following code could be used:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { counter } from "your-package";\nimport { provideFASTDesignSystem, fastButton } from "@microsoft/fast-components";\n\nprovideFASTDesignSystem()\n    .register(\n        fastButton(),\n        counter({ defaultButtonContent: "Please count." })\n    );\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The advantage of setting ",(0,o.jsx)(n.code,{children:"defaultButtonContent"})," here is that it overrides the ",(0,o.jsx)(n.code,{children:"Counter"}),"'s default slotted content for ",(0,o.jsx)(n.strong,{children:"all"})," instances of ",(0,o.jsx)(n.code,{children:"your-counter"}),". Instead of having to define it everywhere in the app that the button is used, the app author provides the configuration once in a centralized location. This can be extremely useful in scenarios where components contain default icons that the app author may need to swap."]}),"\n",(0,o.jsx)(n.h2,{id:"defining-a-design-system",children:"Defining a design system"}),"\n",(0,o.jsxs)(n.p,{children:["The above examples show how to build a single component that can be flexibly registered with an existing design system. But, you can create your own design system as well. To do so, you would start with the base components defined in ",(0,o.jsx)(n.code,{children:"@microsoft/fast-foundation"})," and compose them with your own styles. You would also define your own ",(0,o.jsx)(n.code,{children:"DesignToken"}),'s to be used within your styles. Finally, you would export a "provider function" for your community to use in setting everything up.']}),"\n",(0,o.jsx)(n.h3,{id:"fast-design-system-thinking",children:"FAST design system thinking"}),"\n",(0,o.jsx)(n.p,{children:"When creating a design system, it can be helpful to think in terms of layers and use cases."}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"foundation components"}),": A reusable set of component classes and templates, independent of any design system, and designed for maximum flexibility."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"design system"}),': Leverages the flexibility of the foundation components, but adds the unique opinions of the design system (e.g. styles, element prefix, design tokens, theme colors, etc). It exports the component registration functions so that apps can decide what to use. This layer may also choose to "lock down" certain options so that the design system remains coherent when used.']}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"application"}),": Registers only the components needed by the app itself."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"features"}),": Only uses the components available in the app. Get access to design tokens to create feature-specific styled components in alignment with the design system."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Notice that the strength of the opinions increases as you proceed down the list, with each layer further constraining the system. When creating a design system, it's important to think through these use cases and consider how different scenarios are impacted."}),"\n",(0,o.jsx)(n.h3,{id:"composing-a-foundation-component",children:"Composing a foundation component"}),"\n",(0,o.jsxs)(n.p,{children:["Let's imagine that we want to add a ",(0,o.jsx)(n.code,{children:"Button"})," to our design system. We only need to import the ",(0,o.jsx)(n.code,{children:"@microsoft/fast-foundation"})," ",(0,o.jsx)(n.code,{children:"Button"})," component class and template, and then compose them with our design system's button styles:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import {\n    Button,\n    buttonTemplate as template,\n} from "@microsoft/fast-foundation";\nimport { buttonStyles as styles } from "./special-button.styles";\n\nexport const specialButton = Button.compose({\n    baseName: "button",\n    template,\n    styles,\n    shadowOptions: {\n        delegatesFocus: true,\n    },\n});\n\nexport const buttonStyles = styles;\n'})}),"\n",(0,o.jsx)(n.p,{children:"As a practice, always be sure to export your styles independently as well. This enables the consumers of your components to build their own versions of your component, reusing and augmenting your styles as needed."}),"\n",(0,o.jsxs)(n.p,{children:["When authoring your own styles, you'll also want to leverage design tokens. Please see ",(0,o.jsx)(n.a,{href:"/docs/1.x/design-systems/design-tokens",children:"the design token documentation"})," for how to create and use design tokens."]}),"\n",(0,o.jsx)(n.h3,{id:"creating-a-design-system-provider-function",children:"Creating a design system provider function"}),"\n",(0,o.jsx)(n.p,{children:'For convenience, and to ensure consistent design system configuration, it\'s a good idea to provide a simple function that sets up your design system. If we wanted to create a function for the "special" design system, we would use the following code:'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'export function provideSpecialDesignSystem(element?: HTMLElement): DesignSystem {\n    return DesignSystem.getOrCreate(element).withPrefix("special");\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The underlying ",(0,o.jsx)(n.code,{children:"DesignSystem.getOrCreate"})," API gets the design system directly attached to the provided element. If one does not exist, it creates one. By default, if no element is provided, the design system is created on the ",(0,o.jsx)(n.code,{children:"document.body"}),". Using this function abstracts those details and provides a much-improved set of ergonomics to those using your components, while also giving you the opportunity to bake in certain configuration yourself, such as defining the default element prefix."]}),"\n",(0,o.jsx)(n.p,{children:"Now consumers of your components can setup your design system in their application with the button component as follows:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"provideSpecialDesignSystem()\n    .register(\n        specialButton()\n    );\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var o=t(14041);const i={},s=o.createContext(i);function a(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);