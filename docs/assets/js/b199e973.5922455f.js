"use strict";(self.webpackChunk_microsoft_fast_site=self.webpackChunk_microsoft_fast_site||[]).push([[75450],{82087:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>r,toc:()=>l});var i=t(31085),s=t(71184);const c={id:"dependency-injection",title:"Dependency Injection",sidebar_label:"Dependency Injection",custom_edit_url:"https://github.com/microsoft/fast/edit/main/sites/website/versioned_docs/version-legacy/apps-and-experiences/dependency-injection.md",description:"FAST introduces the concept of a dependency injection container.",keywords:["dependency injection container"]},o=void 0,r={id:"apps-and-experiences/dependency-injection",title:"Dependency Injection",description:"FAST introduces the concept of a dependency injection container.",source:"@site/versioned_docs/version-1.x/apps-and-experiences/dependency-injection.md",sourceDirName:"apps-and-experiences",slug:"/apps-and-experiences/dependency-injection",permalink:"/docs/1.x/apps-and-experiences/dependency-injection",draft:!1,unlisted:!1,editUrl:"https://github.com/microsoft/fast/edit/main/sites/website/versioned_docs/version-legacy/apps-and-experiences/dependency-injection.md",tags:[],version:"1.x",frontMatter:{id:"dependency-injection",title:"Dependency Injection",sidebar_label:"Dependency Injection",custom_edit_url:"https://github.com/microsoft/fast/edit/main/sites/website/versioned_docs/version-legacy/apps-and-experiences/dependency-injection.md",description:"FAST introduces the concept of a dependency injection container.",keywords:["dependency injection container"]},sidebar:"docs",previous:{title:"Apps and Experiences",permalink:"/docs/1.x/category/apps-and-experiences"},next:{title:"Integrations",permalink:"/docs/1.x/category/integrations"}},a={},l=[{value:"Creating a DI Container",id:"creating-a-di-container",level:2},{value:"Example Scenario",id:"example-scenario",level:3},{value:"Creating DI Keys",id:"creating-di-keys",level:2},{value:"Registering Dependencies",id:"registering-dependencies",level:2},{value:"Constructor Injection",id:"constructor-injection",level:2},{value:"DI Key and Inject Patterns",id:"di-key-and-inject-patterns",level:2},{value:"Other DI Registration Approaches",id:"other-di-registration-approaches",level:2},{value:"Auto-registration",id:"auto-registration",level:3},{value:"Default Registration",id:"default-registration",level:3},{value:"Injecting into Web Components",id:"injecting-into-web-components",level:2}];function d(e){const n={admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"An important principle of object oriented programming (OOP) is to favor a compositional approach to systems over an inheritance-based approach. In such systems, complex problems are broken down into small, single-purpose objects that collaborate with one another. However, this approach is not a panacea, and introduces its own set of challenges:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"How do we instantiate a set of collaborating objects, particularly when there is a complex arrangement of dependencies between the objects?"}),"\n",(0,i.jsx)(n.li,{children:"How do we avoid tight coupling between an object and the implementation details of its dependencies?"}),"\n",(0,i.jsx)(n.li,{children:"How do we manage memory and control the lifetimes of objects in such a system?"}),"\n",(0,i.jsx)(n.li,{children:"How does our user interface, often controlled by a different engine, gain access to our composed system capabilities?"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["To address these challenges, FAST introduces the concept of a ",(0,i.jsx)(n.em,{children:"dependency injection container"}),". A DI Container is a sub-system with the responsibilities of understanding dependency relationships, constructing objects with their dependencies, delivering dependencies to components, and managing lifetimes."]}),"\n",(0,i.jsx)(n.h2,{id:"creating-a-di-container",children:"Creating a DI Container"}),"\n",(0,i.jsxs)(n.p,{children:["DI Containers can exist in a hierarchy, allowing child containers to override the dependencies of the parent, but typically there is one root container in which all the system's services are registered. In a typical FAST application, you will want this container to be associated with the ",(0,i.jsx)(n.code,{children:"document.body"})," so that all UI component children can gain access to its capabilities. Here's how you would create that root container:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'import { DI } from "@microsoft/fast-foundation";\n\nconst container = DI.getOrCreateDOMContainer();\n'})}),"\n",(0,i.jsxs)(n.p,{children:["You'll want to create and configure your root container as early as possible in your application lifecycle, typically in your application's entry point module. If you are using FAST's Design System features or its components, we've integrated them with DI, so that you can configure everything with a unified API. Instead of calling ",(0,i.jsx)(n.code,{children:"DI.getOrCreateDOMContainer()"})," you can simply import the Design System Provider function and use that. Here's some code that you may have seen in other parts of our documentation, that does just that:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"provideFASTDesignSystem()\n    .register(\n        fastButton()\n    );\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"register"})," method of the ",(0,i.jsx)(n.code,{children:"DesignSystem"})," actually delegates directly to the DI container. As a result, you can register your Web Components and all your application dependencies in the same place, following the same patterns."]}),"\n",(0,i.jsx)(n.h3,{id:"example-scenario",children:"Example Scenario"}),"\n",(0,i.jsxs)(n.p,{children:["Once you have a container, you can use it to register and retrieve system dependencies. This is best demonstrated with a typical scenario. Imagine that we have a ",(0,i.jsx)(n.code,{children:"NewAccountScreen"})," web component in our app. Users navigate to this screen to create a new account. This screen is dependent on an ",(0,i.jsx)(n.code,{children:"AccountService"}),", which is able to create accounts and login new users. The ",(0,i.jsx)(n.code,{children:"AccountService"})," itself is dependent on a ",(0,i.jsx)(n.code,{children:"UserSession"})," and an ",(0,i.jsx)(n.code,{children:"HTTPClient"}),". The ",(0,i.jsx)(n.code,{children:"HTTPClient"})," is dependent on a ",(0,i.jsx)(n.code,{children:"ServiceBaseURL"})," string. Let's set this up, working from the inside out."]}),"\n",(0,i.jsx)(n.h2,{id:"creating-di-keys",children:"Creating DI Keys"}),"\n",(0,i.jsxs)(n.p,{children:["The FAST DI can handle any kind of dependency, including primitive values like strings. Simply register a ",(0,i.jsx)(n.code,{children:"ServiceBaseURL"})," with the container and any HTTP service that needs it can simply request it by key. This allows for a centralized configuration, making it easy to swap out in different environments. Here's how you define a strongly typed ",(0,i.jsx)(n.em,{children:"key"})," that symbolizes an interface to a dependency."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'import { DI } from "@microsoft/fast-foundation";\n\nexport const ServiceBaseURL = DI.createInterface<string>();\n'})}),"\n",(0,i.jsx)(n.h2,{id:"registering-dependencies",children:"Registering Dependencies"}),"\n",(0,i.jsx)(n.p,{children:"Once an interface key is defined, you'll want to register a concrete value with the root container. That can be done like so:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'container.register(\n    Registration.instance(ServiceBaseURL, "https://www.fast.design/")\n);\n'})}),"\n",(0,i.jsx)(n.p,{children:"Or through the design system like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'provideFASTDesignSystem()\n    .register(\n        Registration.instance(ServiceBaseURL, "https://www.fast.design/")\n    );\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The container (and the Design System) has a ",(0,i.jsx)(n.code,{children:"register"})," method that takes a variable number of ",(0,i.jsx)(n.code,{children:"Registry"})," instances. The ",(0,i.jsx)(n.code,{children:"Registration"})," object is a helper for creating registrations with various behaviors. Here is a summary of what's available on the ",(0,i.jsx)(n.code,{children:"Registration"})," object:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"instance"})," - Configures an existing object instance. Every request with the key will return this exact instance."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"singleton"})," - Configures a class that is instantiated when the Key is first requested. All successive requests with the same key will return the cached instance."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"transient"})," - Configures a class that is instantiated for each request with the Key. This means that each requestor gets a new instance."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"callback"})," - Configures a function callback. Every time the Key is requested, the callback will be run, allowing custom code to dynamically return values."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"cachedCallback"})," - Configures a function callback. The first time the Key is requested, the callback will be run to return a value. Successive calls return the cached value without invoking the callback again."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"aliasTo"})," - Configures a Key to act as an alias to another Key."]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["Component functions like ",(0,i.jsx)(n.code,{children:"fastButton()"})," actually return an instance of ",(0,i.jsx)(n.code,{children:"Registry"})," that is responsible for obtaining contextual information from the DI container and using it to register the Web Component with FAST. You can follow this same pattern not only with your own components but with any configurable, shared dependency."]})}),"\n",(0,i.jsx)(n.h2,{id:"constructor-injection",children:"Constructor Injection"}),"\n",(0,i.jsxs)(n.p,{children:["The above code defines a key for the ",(0,i.jsx)(n.code,{children:"ServiceBaseURL"})," and configures a value for the container, but how do we get that value to the ",(0,i.jsx)(n.code,{children:"HTTPClient"}),"? Since ",(0,i.jsx)(n.code,{children:"HTTPClient"})," is a plain class (as opposed to a web component), we'll leverage constructor injection. To do so, we declare that our constructor is dependent on ",(0,i.jsx)(n.code,{children:"ServiceBaseURL"})," as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export class HTTPClient {\n    constructor(@ServiceBaseURL serviceBaseURL: string) {}\n    public get<T>(url: string): Promise<T> { ... }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Notice that in TypeScript, we can use the key as a decorator for the constructor parameter. This tells the DI container that when it creates an instance of ",(0,i.jsx)(n.code,{children:"HTTPClient"})," it should first resolve ",(0,i.jsx)(n.code,{children:"ServiceBaseURL"})," since it will need to provide that as the first parameter when constructing ",(0,i.jsx)(n.code,{children:"HTTPClient"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"di-key-and-inject-patterns",children:"DI Key and Inject Patterns"}),"\n",(0,i.jsxs)(n.p,{children:["Our ",(0,i.jsx)(n.code,{children:"ServiceBaseURL"})," represented a simple string. So, how do we handle something more complex like ",(0,i.jsx)(n.code,{children:"HTTPClient"}),"? After all, we want that to be injected into the ",(0,i.jsx)(n.code,{children:"AccountService"}),". A common pattern is to create an interface for ",(0,i.jsx)(n.code,{children:"HTTPClient"})," and a key with the same name. TypeScript allows these to be named the same, which works to our advantage here."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export interface HTTPClient {\n    get<T>(url: string): Promise<T>;\n}\n\nexport const HTTPClient = DI.createInterface<HTTPClient>();\n\nexport class DefaultHTTPClient implements HTTPClient {\n    constructor(@ServiceBaseURL serviceBaseURL: string) {}\n    public get<T>(url: string): Promise<T> { ... }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We could follow the same pattern for the ",(0,i.jsx)(n.code,{children:"UserSession"})," as well, but let's look at a different approach. Sometimes, you may find that having the extra interface/implementation with interface key abstraction is an over-complication for your use case. You don't have to create a custom key if you just want to inject a concrete class. The ",(0,i.jsx)(n.code,{children:"AccountService"})," could declare its dependencies using the generic ",(0,i.jsx)(n.code,{children:"inject"})," decorator like so:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export class AccountService {\n    constructor(\n        @HttpClient http: HttpClient, \n        @inject(UserSession) session: UserSession\n    ) {}\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Better yet, if you are using the ",(0,i.jsx)(n.code,{children:"tsconfig.json"})," setting ",(0,i.jsx)(n.code,{children:'"emitDecoratorMetadata": true'})," then you can even do this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export class AccountService {\n    constructor(\n        @HttpClient http: HttpClient, \n        @inject() session: UserSession\n    ) {}\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"other-di-registration-approaches",children:"Other DI Registration Approaches"}),"\n",(0,i.jsxs)(n.p,{children:["Above, we saw that ",(0,i.jsx)(n.code,{children:"ServiceBaseURL"})," had to be explicitly registered with the container. Otherwise, how else would we know what string to resolve? However, explicit registration with the container is not always needed."]}),"\n",(0,i.jsx)(n.h3,{id:"auto-registration",children:"Auto-registration"}),"\n",(0,i.jsxs)(n.p,{children:["In the case of ",(0,i.jsx)(n.code,{children:"UserSession"})," above, the container will use ",(0,i.jsx)(n.code,{children:"UserSession"})," directly as the key. However, since we have not explicitly registered ",(0,i.jsx)(n.code,{children:"UserSession"})," in the container, it will attempt to use the key itself as the registration. As a result, it will instantiate ",(0,i.jsx)(n.code,{children:"UserSession"})," and then register the instance. Another way of thinking of this is that auto-registered classes are treated as singletons by default."]}),"\n",(0,i.jsx)(n.h3,{id:"default-registration",children:"Default Registration"}),"\n",(0,i.jsxs)(n.p,{children:["We've seen how we can explicitly register dependencies with the container and also how classes can be auto-registered. A third approach is to have the key itself define a default registration. If defined, this registration will be used if no other registration for the same key is configured with the container. We could set the ",(0,i.jsx)(n.code,{children:"AccountService"})," up to work this way if we desired. Here's what that would look like:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export interface AccountService {\n    ...\n}\n\nclass DefaultAccountService implements AccountService {\n    constructor(\n        @HttpClient http: HttpClient, \n        @inject() session: UserSession\n    ) {}\n}\n\nexport const AccountService = DI.createInterface<AccountService>(\n    x => x.singleton(DefaultAccountService)\n);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"injecting-into-web-components",children:"Injecting into Web Components"}),"\n",(0,i.jsxs)(n.p,{children:["Ultimately, our ",(0,i.jsx)(n.code,{children:"NewAccountScreen"})," web component needs our ",(0,i.jsx)(n.code,{children:"AccountService"}),". Unfortunately, web components must have parameterless constructors. To complicate matters further, the constructor is usually called by the web browser's runtime itself while parsing HTML, so our DI container is completely blocked from the process."]}),"\n",(0,i.jsx)(n.p,{children:"To address this, the FAST DI supports property injection on web components. Here's how we would declare the dependency:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export class NewAccountScreen extends FASTElement {\n    @AccountService accountService!: AccountService;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["With the property defined as above, the ",(0,i.jsx)(n.code,{children:"accountService"})," property will be available to access from the ",(0,i.jsx)(n.code,{children:"connectedCallback"})," lifecycle hook forward."]}),"\n",(0,i.jsxs)(n.p,{children:["Alternatively, like with constructor injection, you can also use the ",(0,i.jsx)(n.code,{children:"inject"})," decorator directly with concrete types. Here's what that looks like:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export class NewAccountScreen extends FASTElement {\n    @inject(MyService) accountService!: MyService;\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},71184:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var i=t(14041);const s={},c=i.createContext(s);function o(e){const n=i.useContext(c);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(c.Provider,{value:n},e.children)}}}]);