"use strict";(self.webpackChunk_microsoft_fast_site=self.webpackChunk_microsoft_fast_site||[]).push([[22781],{53336:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});var s=n(31085),i=n(71184);const a={id:"declaring-templates",title:"Declaring Templates",sidebar_label:"Declaring Templates",custom_edit_url:"https://github.com/microsoft/fast/edit/main/sites/website/versioned_docs/version-legacy/fast-element/declaring-templates.md",description:"While you can create and update nodes in the Shadow DOM manually, FASTElement provides a streamlined templating system for the most common rendering scenarios.",keywords:["declaring templates"]},l=void 0,r={id:"fast-element/declaring-templates",title:"Declaring Templates",description:"While you can create and update nodes in the Shadow DOM manually, FASTElement provides a streamlined templating system for the most common rendering scenarios.",source:"@site/versioned_docs/version-1.x/fast-element/declaring-templates.md",sourceDirName:"fast-element",slug:"/fast-element/declaring-templates",permalink:"/docs/1.x/fast-element/declaring-templates",draft:!1,unlisted:!1,editUrl:"https://github.com/microsoft/fast/edit/main/sites/website/versioned_docs/version-legacy/fast-element/declaring-templates.md",tags:[],version:"1.x",frontMatter:{id:"declaring-templates",title:"Declaring Templates",sidebar_label:"Declaring Templates",custom_edit_url:"https://github.com/microsoft/fast/edit/main/sites/website/versioned_docs/version-legacy/fast-element/declaring-templates.md",description:"While you can create and update nodes in the Shadow DOM manually, FASTElement provides a streamlined templating system for the most common rendering scenarios.",keywords:["declaring templates"]},sidebar:"docs",previous:{title:"Defining Elements",permalink:"/docs/1.x/fast-element/defining-elements"},next:{title:"Using Directives",permalink:"/docs/1.x/fast-element/using-directives"}},o={},d=[{value:"Basic templates",id:"basic-templates",level:2},{value:"Typed Templates",id:"typed-templates",level:3},{value:"Understanding bindings",id:"understanding-bindings",level:2},{value:"Content",id:"content",level:3},{value:"Attributes",id:"attributes",level:3},{value:"Properties",id:"properties",level:3},{value:"Events",id:"events",level:3},{value:"Templating and the element lifecycle",id:"templating-and-the-element-lifecycle",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"basic-templates",children:"Basic templates"}),"\n",(0,s.jsxs)(t.p,{children:["While you can create and update nodes in the Shadow DOM manually, ",(0,s.jsx)(t.code,{children:"FASTElement"})," provides a streamlined templating system for the most common rendering scenarios. To create an HTML template for an element, import and use the ",(0,s.jsx)(t.code,{children:"html"})," tagged template helper and pass the template to the ",(0,s.jsx)(t.code,{children:"@customElement"})," decorator."]}),"\n",(0,s.jsxs)(t.p,{children:["Here's how we would add a template for our ",(0,s.jsx)(t.code,{children:"name-tag"})," component that renders some basic structure as well as our ",(0,s.jsx)(t.code,{children:"greeting"}),":"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsxs)(t.strong,{children:["Example: Adding a Template to a ",(0,s.jsx)(t.code,{children:"FASTElement"})]})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"import { FASTElement, customElement, attr, html } from '@microsoft/fast-element';\n\nconst template = html<NameTag>`\n  <div class=\"header\">\n    <h3>${x => x.greeting.toUpperCase()}</h3>\n    <h4>my name is</h4>\n  </div>\n\n  <div class=\"body\">TODO: Name Here</div>\n\n  <div class=\"footer\"></div>\n`;\n\n@customElement({\n  name: 'name-tag',\n  template\n})\nexport class NameTag extends FASTElement {\n  @attr greeting: string = 'Hello';\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"There are several important details in the above example, so let's break them down one-by-one."}),"\n",(0,s.jsxs)(t.p,{children:["First, we create a template by using a ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals",children:"tagged template literal"}),". The tag, ",(0,s.jsx)(t.code,{children:"html"}),", provides special processing for the HTML string that follows, returning an instance of ",(0,s.jsx)(t.code,{children:"ViewTemplate"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Within a template, we provide ",(0,s.jsx)(t.em,{children:"bindings"})," that declare the ",(0,s.jsx)(t.em,{children:"dynamic parts"})," of our template. These bindings are declared with ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions",children:"arrow functions"}),". Because the template is typed, the input to your arrow function will be an instance of the data model you declared in your ",(0,s.jsx)(t.code,{children:"html"})," tag. When the ",(0,s.jsx)(t.code,{children:"html"})," tag processes your template, it identifies these dynamic expressions and builds up an optimized model, capable of high-performance rendering, and efficient, incremental batched updates."]}),"\n",(0,s.jsxs)(t.p,{children:["Finally, we associate the template with our custom element by using a new form of the ",(0,s.jsx)(t.code,{children:"@customElement"})," decorator, which allows us to pass more options. In this configuration, we pass an options object specifying the ",(0,s.jsx)(t.code,{children:"name"})," and the ",(0,s.jsx)(t.code,{children:"template"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["With this in place, we now have a ",(0,s.jsx)(t.code,{children:"name-tag"})," element that will render its template into the Shadow DOM and automatically update the ",(0,s.jsx)(t.code,{children:"h3"})," content whenever the name tag's ",(0,s.jsx)(t.code,{children:"greeting"})," attribute changes. Give it a try!"]}),"\n",(0,s.jsx)(t.h3,{id:"typed-templates",children:"Typed Templates"}),"\n",(0,s.jsxs)(t.p,{children:["Your templates can be ",(0,s.jsx)(t.em,{children:"typed"})," to the data model that they are rendering over. In TypeScript, we provide the type as part of the tag: ",(0,s.jsx)(t.code,{children:"html<NameTag>"}),". For TypeScript 3.8 or higher, you can import ",(0,s.jsx)(t.code,{children:"ViewTemplate"})," as a type:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"import type { ViewTemplate } from '@microsoft/fast-element';\n\nconst template: ViewTemplate<NameTag> = html`\n  <div>${x => x.greeting}</div>\n`;\n"})}),"\n",(0,s.jsx)(t.h2,{id:"understanding-bindings",children:"Understanding bindings"}),"\n",(0,s.jsx)(t.p,{children:"We've seen how arrow functions can be used to declare dynamic parts of templates. Let's look at a few more examples to see the breadth of what is available to you."}),"\n",(0,s.jsx)(t.h3,{id:"content",children:"Content"}),"\n",(0,s.jsx)(t.p,{children:"To bind the content of an element, simply provide the expression within the start and end tags of the element. It can be the sole content of the element or interwoven with other elements and text."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Example: Basic Text Content"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-html",children:"<h3>${x => x.greeting.toUpperCase()}</h3>\n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Example: Interpolated Text Content"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-html",children:"<h3>${x => x.greeting}, my name is ${x => x.name}.</h3>\n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Example: Heterogeneous Content"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-html",children:'<h3>\n  ${x => x.greeting}, my name is\n  <span class="name">${x => x.name}</span>.\n</h3>\n'})}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["Dynamic content is set via the ",(0,s.jsx)(t.code,{children:"textContent"})," HTML property for security reasons. You ",(0,s.jsx)(t.em,{children:"cannot"})," set HTML content this way. See below for the explicit, opt-in mechanism for setting HTML."]})}),"\n",(0,s.jsx)(t.h3,{id:"attributes",children:"Attributes"}),"\n",(0,s.jsxs)(t.p,{children:["You can also use an expression to set an attribute value on an HTML Element. Simply place the expression where the value of the HTML attribute would go. The template engine will then use your expression to set the value using ",(0,s.jsx)(t.code,{children:"setAttribute(...)"}),", whenever it needs to be updated. Additionally, some attributes are known as ",(0,s.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes#Boolean_Attributes",children:"boolean attributes"})," (e.g. required, readonly, disabled). These attributes behave differently from normal attributes and need special value handling. The templating engine will handle this for you if you prepend the attribute name with a ",(0,s.jsx)(t.code,{children:"?"}),"."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Example: Basic Attribute Values"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-html",children:'<a href="${x => x.aboutLink}">About</a>\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Example: Interpolated Attribute Values"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-html",children:'<a href="products/${x => x.id}">\n  ${x => x.name}\n</a>\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-html",children:'<li class="list-item ${x => x.type}">\n  ...\n</li>\n'})}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsxs)(t.p,{children:["When binding to ",(0,s.jsx)(t.code,{children:"class"}),', the underlying engine will not over-write classes added to the element via other mechanisms. It only adds and removes classes that result directly from the binding. This "safe by default" behavior does come at a slight performance cost. To opt-out of this feature and squeeze out every ounce of performance by always overwriting all classes, use a property binding (see below) on the ',(0,s.jsx)(t.code,{children:"className"})," property. e.g. ",(0,s.jsx)(t.code,{children:':className="list-item ${x => x.type}"'}),"."]})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-html",children:"<span style=\"text-decoration: ${x => x.done ? 'line-through' : ''}\">\n  ${x => x.description}\n</span>\n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Example: ARIA Attributes"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-html",children:'<div role="progressbar"\n     aria-valuenow="${x => x.value}"\n     aria-valuemin="${x => x.min}"\n     aria-valuemax="${x => x.max}">\n</div>\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Example: Boolean Attributes"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-html",children:'<button type="submit" ?disabled="${x => !x.enabled}">Submit</button>\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Example: Nullish value"})}),"\n",(0,s.jsxs)(t.p,{children:["Some cases may occur where an attribute needs to have a value when used however not present if unused. These are different than boolean attributes by where their presence alone triggers their effect. In this situation, a nullish value (",(0,s.jsx)(t.code,{children:"null"})," or ",(0,s.jsx)(t.code,{children:"undefined"}),") may be provided so the attribute won't exist in that condition."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-html",children:"<div aria-hidden=\"${x => x.isViewable ? 'true' : null}\"></div>\n"})}),"\n",(0,s.jsx)(t.h3,{id:"properties",children:"Properties"}),"\n",(0,s.jsxs)(t.p,{children:["Properties can also be set directly on an HTML element. To do so, prepend the property name with ",(0,s.jsx)(t.code,{children:":"})," to indicate a property binding. The template engine will then use your expression to assign the element's property value."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Example: Basic Property Values"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-html",children:'<my-element :myCustomProperty="${x => x.mySpecialData}">\n  ...\n</my-element>\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Example: Inner HTML"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-html",children:'<div :innerHTML="${x => x.someDangerousHTMLContent}"></div>\n'})}),"\n",(0,s.jsxs)(t.admonition,{type:"warning",children:[(0,s.jsx)(t.p,{children:"Avoid scenarios that require you to directly set HTML, especially when the content is coming from an external source. If you must do this, you should always sanitize the HTML."}),(0,s.jsxs)(t.p,{children:["The best way to accomplish HTML sanitization is to configure ",(0,s.jsx)(t.a,{href:"https://w3c.github.io/trusted-types/dist/spec/",children:"a trusted types policy"})," with FASTElement's template engine. FASTElement ensures that all HTML strings pass through the configured policy. Also, by leveraging the platform's trusted types capabilities, you get native enforcement of the policy through CSP headers. Here's an example of how to configure a custom policy to sanitize HTML:"]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"import { DOM } from '@microsoft/fast-element';\n\nconst myPolicy = trustedTypes.createPolicy('my-policy', {\n  createHTML(html) {\n    // TODO: invoke a sanitization library on the html before returning it\n    return html;\n  }\n});\n\nDOM.setHTMLPolicy(myPolicy);\n"})}),(0,s.jsx)(t.p,{children:"For security reasons, the HTML Policy can only be set once. For this reason, it should be set by application developers and not by component authors, and it should be done immediately during the startup sequence of the application."})]}),"\n",(0,s.jsx)(t.h3,{id:"events",children:"Events"}),"\n",(0,s.jsxs)(t.p,{children:["Besides rendering content, attributes, and properties, you'll often want to add event listeners and execute code when events fire. To do that, prepend the event name with ",(0,s.jsx)(t.code,{children:"@"})," and provide the expression to be called when that event fires. Within an event binding, you also have access to a special ",(0,s.jsx)(t.em,{children:"context"})," argument from which you can access the ",(0,s.jsx)(t.code,{children:"event"})," object."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Example: Basic Events"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-html",children:'<button @click="${x => x.remove()}">Remove</button>\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Example: Accessing Event Details"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-html",children:'<input type="text"\n       :value="${x => x.description}"\n       @input="${(x, c) => x.handleDescriptionChange(c.event)}">\n'})}),"\n",(0,s.jsx)(t.admonition,{type:"important",children:(0,s.jsxs)(t.p,{children:["In both examples above, after your event handler is executed, ",(0,s.jsx)(t.code,{children:"preventDefault()"})," will be called on the event object by default. You can return ",(0,s.jsx)(t.code,{children:"true"})," from your handler to opt-out of this behavior."]})}),"\n",(0,s.jsxs)(t.p,{children:["The second example demonstrates an important characteristic of the templating engine: it only supports ",(0,s.jsx)(t.em,{children:"unidirectional data flow"})," (",(0,s.jsx)(t.code,{children:"model => view"}),"). It does not support ",(0,s.jsx)(t.em,{children:"two-way data binding"})," (",(0,s.jsx)(t.code,{children:"model <=> view"}),"). As shown above, pushing data from the view back to the model should be handled with explicit events that call into your model's API."]}),"\n",(0,s.jsx)(t.h2,{id:"templating-and-the-element-lifecycle",children:"Templating and the element lifecycle"}),"\n",(0,s.jsxs)(t.p,{children:["It is during the ",(0,s.jsx)(t.code,{children:"connectedCallback"})," phase of the Custom Element lifecycle that ",(0,s.jsx)(t.code,{children:"FASTElement"})," creates templates and binds the resulting view. The creation of the template only occurs the first time the element is connected, while binding happens every time the element is connected (with unbinding happening during the ",(0,s.jsx)(t.code,{children:"disconnectedCallback"})," for symmetry)."]}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsx)(t.p,{children:"In the future, we're planning new optimizations that will enable us to safely determine when we do not need to unbind/rebind certain views."})}),"\n",(0,s.jsxs)(t.p,{children:["In most cases, the template that ",(0,s.jsx)(t.code,{children:"FASTElement"})," renders is determined by the ",(0,s.jsx)(t.code,{children:"template"})," property of the Custom Element's configuration. However, you can also implement a method on your Custom Element class named ",(0,s.jsx)(t.code,{children:"resolveTemplate()"})," that returns a template instance. If this method is present, it will be called during ",(0,s.jsx)(t.code,{children:"connectedCallback"})," to obtain the template to use. This allows the element author to dynamically select completely different templates based on the state of the element at the time of connection."]}),"\n",(0,s.jsxs)(t.p,{children:["In addition to dynamic template selection during the ",(0,s.jsx)(t.code,{children:"connectedCallback"}),", the ",(0,s.jsx)(t.code,{children:"$fastController"})," property of ",(0,s.jsx)(t.code,{children:"FASTElement"})," enables dynamically changing the template at any time by setting the controller's ",(0,s.jsx)(t.code,{children:"template"})," property to any valid template."]}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsxs)(t.p,{children:["Check out ",(0,s.jsx)(t.a,{href:"/docs/1.x/resources/cheat-sheet#bindings",children:"our Cheat Sheet"})," for a quick guide on bindings."]})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},71184:(e,t,n)=>{n.d(t,{R:()=>l,x:()=>r});var s=n(14041);const i={},a=s.createContext(i);function l(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);